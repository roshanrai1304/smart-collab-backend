"""
AI Services models for Smart Collaborative Backend.

This module defines the AI processing and metadata structure:
- AIDocumentMetadata (AI processing results and embeddings)
- AIProcessingQueue (task queue tracking)
- AISuggestionsCache (caching for AI suggestions)
"""

import uuid
from datetime import timedelta

from django.contrib.auth.models import User
from django.core.exceptions import ValidationError
from django.db import models
from django.utils import timezone
from pgvector.django import VectorField

from apps.documents.models import Document
from apps.organizations.models import Organization, Team


class AIDocumentMetadata(models.Model):
    """
    AI-generated metadata and analysis results for documents.
    Stores summaries, tags, embeddings, and other AI-derived insights.
    """

    PROCESSING_STATUS_CHOICES = [
        ("pending", "Pending"),
        ("processing", "Processing"),
        ("completed", "Completed"),
        ("failed", "Failed"),
        ("skipped", "Skipped"),
    ]

    CONTENT_TYPES = [
        ("article", "Article"),
        ("report", "Report"),
        ("meeting_notes", "Meeting Notes"),
        ("proposal", "Proposal"),
        ("technical_doc", "Technical Document"),
        ("presentation", "Presentation"),
        ("other", "Other"),
    ]

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Document relationships
    document = models.OneToOneField(
        Document,
        on_delete=models.CASCADE,
        related_name="ai_metadata",
        help_text="Associated document"
    )
    organization = models.ForeignKey(
        Organization,
        on_delete=models.CASCADE,
        help_text="Organization for partitioning"
    )

    # Processing status and metadata
    processing_status = models.CharField(
        max_length=20,
        choices=PROCESSING_STATUS_CHOICES,
        default="pending",
        help_text="Current processing status"
    )
    last_processed = models.DateTimeField(
        null=True,
        blank=True,
        help_text="Timestamp of last successful processing"
    )
    processing_version = models.CharField(
        max_length=50,
        default="1.0",
        help_text="Version of processing pipeline"
    )
    model_version = models.CharField(
        max_length=50,
        blank=True,
        help_text="AI model version used"
    )

    # Content analysis results
    summary = models.TextField(
        blank=True,
        help_text="AI-generated document summary"
    )
    key_points = models.JSONField(
        default=list,
        blank=True,
        help_text="Extracted key points with confidence scores"
    )
    auto_tags = models.JSONField(
        default=list,
        blank=True,
        help_text="AI-generated tags"
    )
    sentiment_score = models.DecimalField(
        max_digits=3,
        decimal_places=2,
        null=True,
        blank=True,
        help_text="Sentiment score (-1.0 to 1.0)"
    )
    readability_score = models.IntegerField(
        null=True,
        blank=True,
        help_text="Flesch reading ease score"
    )
    detected_content_type = models.CharField(
        max_length=50,
        choices=CONTENT_TYPES,
        blank=True,
        help_text="AI-detected document type"
    )

    # Vector embeddings (using pgvector)
    embedding_vector = VectorField(
        dimensions=4096,  # qwen3-embedding:8b supports up to 4096 dimensions
        null=True,
        blank=True,
        help_text="Document embedding vector generated by qwen3-embedding:8b"
    )
    embedding_model = models.CharField(
        max_length=50,
        blank=True,
        help_text="Model used for embeddings"
    )

    # Quality and performance metrics
    confidence_scores = models.JSONField(
        default=dict,
        blank=True,
        help_text="Confidence scores for AI outputs"
    )
    processing_time_ms = models.IntegerField(
        null=True,
        blank=True,
        help_text="Processing time in milliseconds"
    )

    # Caching metadata
    cache_key = models.CharField(
        max_length=128,
        blank=True,
        help_text="Cache key for this metadata"
    )
    expires_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text="Cache expiration time"
    )

    # Error tracking
    error_message = models.TextField(
        blank=True,
        help_text="Error message if processing failed"
    )
    retry_count = models.IntegerField(
        default=0,
        help_text="Number of processing retries"
    )

    # Timestamps
    created_at = models.DateTimeField(default=timezone.now)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = "ai_document_metadata"
        ordering = ["-updated_at"]
        indexes = [
            models.Index(fields=["document"], name="idx_ai_meta_document"),
            models.Index(fields=["organization"], name="idx_ai_meta_org"),
            models.Index(fields=["processing_status"], name="idx_ai_meta_status"),
            models.Index(fields=["last_processed"], name="idx_ai_meta_processed"),
            models.Index(fields=["detected_content_type"], name="idx_ai_meta_content_type"),
            models.Index(fields=["expires_at"], name="idx_ai_meta_expires"),
        ]

    def __str__(self):
        return f"AI Metadata for {self.document.title}"

    def is_processing_needed(self):
        """Check if document needs AI processing."""
        if self.processing_status in ["pending", "failed"]:
            return True
        
        # Check if document was updated after last processing
        if self.last_processed and self.document.updated_at > self.last_processed:
            return True
            
        return False

    def mark_processing_started(self):
        """Mark the metadata as currently being processed."""
        self.processing_status = "processing"
        self.save(update_fields=["processing_status", "updated_at"])

    def mark_processing_completed(self, processing_time_ms=None):
        """Mark processing as completed successfully."""
        self.processing_status = "completed"
        self.last_processed = timezone.now()
        self.retry_count = 0
        self.error_message = ""
        
        if processing_time_ms:
            self.processing_time_ms = processing_time_ms
            
        self.save(update_fields=[
            "processing_status", "last_processed", "retry_count", 
            "error_message", "processing_time_ms", "updated_at"
        ])

    def mark_processing_failed(self, error_message=""):
        """Mark processing as failed."""
        self.processing_status = "failed"
        self.retry_count += 1
        self.error_message = error_message
        self.save(update_fields=[
            "processing_status", "retry_count", "error_message", "updated_at"
        ])

    @property
    def should_retry(self):
        """Check if processing should be retried."""
        return self.processing_status == "failed" and self.retry_count < 3


class AIProcessingQueue(models.Model):
    """
    Queue for tracking AI processing tasks.
    Provides visibility into processing pipeline and debugging.
    """

    TASK_TYPES = [
        ("summarize", "Document Summarization"),
        ("tag", "Tag Extraction"),
        ("embed", "Embedding Generation"),
        ("analyze", "Content Analysis"),
        ("all", "Complete Processing"),
    ]

    QUEUE_STATUS_CHOICES = [
        ("queued", "Queued"),
        ("processing", "Processing"),
        ("completed", "Completed"),
        ("failed", "Failed"),
        ("cancelled", "Cancelled"),
    ]

    PRIORITY_CHOICES = [
        (1, "Critical"),
        (2, "High"),
        (3, "Normal"),
        (4, "Low"),
        (5, "Background"),
    ]

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Task identification
    document = models.ForeignKey(
        Document,
        on_delete=models.CASCADE,
        related_name="ai_processing_tasks"
    )
    task_type = models.CharField(
        max_length=50,
        choices=TASK_TYPES,
        help_text="Type of AI processing task"
    )
    priority = models.IntegerField(
        choices=PRIORITY_CHOICES,
        default=3,
        help_text="Task priority (1=highest, 5=lowest)"
    )

    # Task status
    status = models.CharField(
        max_length=20,
        choices=QUEUE_STATUS_CHOICES,
        default="queued"
    )
    celery_task_id = models.CharField(
        max_length=255,
        blank=True,
        help_text="Celery task ID for tracking"
    )

    # Task data
    input_data = models.JSONField(
        default=dict,
        blank=True,
        help_text="Input parameters for the task"
    )
    output_data = models.JSONField(
        default=dict,
        blank=True,
        help_text="Task results and outputs"
    )
    
    # Error tracking
    error_message = models.TextField(
        blank=True,
        help_text="Error message if task failed"
    )
    retry_count = models.IntegerField(
        default=0,
        help_text="Number of retries attempted"
    )

    # Performance tracking
    processing_time_ms = models.IntegerField(
        null=True,
        blank=True,
        help_text="Task processing time in milliseconds"
    )
    
    # Timestamps
    created_at = models.DateTimeField(default=timezone.now)
    started_at = models.DateTimeField(null=True, blank=True)
    completed_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = "ai_processing_queue"
        ordering = ["priority", "-created_at"]
        indexes = [
            models.Index(fields=["document", "task_type"], name="idx_ai_queue_doc_type"),
            models.Index(fields=["status", "priority"], name="idx_ai_queue_status_priority"),
            models.Index(fields=["celery_task_id"], name="idx_ai_queue_celery_id"),
            models.Index(fields=["created_at"], name="idx_ai_queue_created"),
        ]

    def __str__(self):
        return f"{self.task_type} - {self.document.title} ({self.status})"

    def mark_started(self, celery_task_id=None):
        """Mark task as started."""
        self.status = "processing"
        self.started_at = timezone.now()
        if celery_task_id:
            self.celery_task_id = celery_task_id
        self.save(update_fields=["status", "started_at", "celery_task_id"])

    def mark_completed(self, output_data=None, processing_time_ms=None):
        """Mark task as completed successfully."""
        self.status = "completed"
        self.completed_at = timezone.now()
        
        if output_data:
            self.output_data = output_data
        if processing_time_ms:
            self.processing_time_ms = processing_time_ms
            
        # Calculate processing time if not provided
        if not processing_time_ms and self.started_at:
            duration = self.completed_at - self.started_at
            self.processing_time_ms = int(duration.total_seconds() * 1000)
            
        self.save(update_fields=[
            "status", "completed_at", "output_data", "processing_time_ms"
        ])

    def mark_failed(self, error_message=""):
        """Mark task as failed."""
        self.status = "failed"
        self.retry_count += 1
        self.error_message = error_message
        self.completed_at = timezone.now()
        
        self.save(update_fields=[
            "status", "retry_count", "error_message", "completed_at"
        ])

    @property
    def should_retry(self):
        """Check if task should be retried."""
        return self.status == "failed" and self.retry_count < 3

    @property
    def duration(self):
        """Get task duration if completed."""
        if self.started_at and self.completed_at:
            return self.completed_at - self.started_at
        return None


class AISuggestionsCache(models.Model):
    """
    Cache for AI-generated suggestions to improve performance.
    Stores suggestions with content hashes for fast retrieval.
    """

    SUGGESTION_TYPES = [
        ("writing", "Writing Assistance"),
        ("formatting", "Formatting Suggestions"),
        ("completion", "Text Completion"),
        ("grammar", "Grammar Check"),
        ("style", "Style Improvement"),
    ]

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Content identification
    content_hash = models.CharField(
        max_length=64,
        unique=True,
        help_text="SHA-256 hash of input content"
    )
    suggestion_type = models.CharField(
        max_length=50,
        choices=SUGGESTION_TYPES,
        help_text="Type of AI suggestion"
    )
    
    # Input and output
    input_text = models.TextField(help_text="Original input text")
    suggestions = models.JSONField(
        default=list,
        help_text="AI-generated suggestions"
    )
    
    # Metadata
    model_version = models.CharField(
        max_length=50,
        blank=True,
        help_text="AI model version used"
    )
    confidence_score = models.DecimalField(
        max_digits=3,
        decimal_places=2,
        null=True,
        blank=True,
        help_text="Confidence score for suggestions"
    )
    
    # Usage tracking
    usage_count = models.IntegerField(
        default=0,
        help_text="Number of times this cache entry was used"
    )
    last_used = models.DateTimeField(
        default=timezone.now,
        help_text="Last time this cache entry was accessed"
    )
    
    # Cache management
    expires_at = models.DateTimeField(
        help_text="Cache expiration time"
    )
    created_at = models.DateTimeField(default=timezone.now)

    class Meta:
        db_table = "ai_suggestions_cache"
        ordering = ["-last_used"]
        indexes = [
            models.Index(fields=["content_hash"], name="idx_ai_cache_hash"),
            models.Index(fields=["suggestion_type"], name="idx_ai_cache_type"),
            models.Index(fields=["expires_at"], name="idx_ai_cache_expires"),
            models.Index(fields=["last_used"], name="idx_ai_cache_last_used"),
        ]

    def __str__(self):
        return f"{self.suggestion_type} cache ({self.content_hash[:8]})"

    def is_expired(self):
        """Check if cache entry has expired."""
        return timezone.now() > self.expires_at

    def mark_used(self):
        """Mark cache entry as used and update counters."""
        self.usage_count += 1
        self.last_used = timezone.now()
        self.save(update_fields=["usage_count", "last_used"])

    @classmethod
    def cleanup_expired(cls):
        """Remove expired cache entries."""
        expired_count = cls.objects.filter(expires_at__lt=timezone.now()).count()
        cls.objects.filter(expires_at__lt=timezone.now()).delete()
        return expired_count


class FeedbackType:
    """Types of feedback that can be collected."""
    SUMMARY_QUALITY = "summary_quality"
    TAG_RELEVANCE = "tag_relevance"
    SEARCH_RELEVANCE = "search_relevance"
    CONTENT_TYPE_ACCURACY = "content_type_accuracy"
    PROCESSING_SPEED = "processing_speed"
    OVERALL_SATISFACTION = "overall_satisfaction"


class UserFeedback(models.Model):
    """
    Model to store user feedback on AI processing results.
    """
    
    FEEDBACK_TYPES = [
        (FeedbackType.SUMMARY_QUALITY, "Summary Quality"),
        (FeedbackType.TAG_RELEVANCE, "Tag Relevance"),
        (FeedbackType.SEARCH_RELEVANCE, "Search Relevance"),
        (FeedbackType.CONTENT_TYPE_ACCURACY, "Content Type Accuracy"),
        (FeedbackType.PROCESSING_SPEED, "Processing Speed"),
        (FeedbackType.OVERALL_SATISFACTION, "Overall Satisfaction"),
    ]
    
    RATING_CHOICES = [
        (1, "Very Poor"),
        (2, "Poor"),
        (3, "Average"),
        (4, "Good"),
        (5, "Excellent"),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='ai_feedback')
    document = models.ForeignKey(
        'documents.Document', 
        on_delete=models.CASCADE, 
        related_name='ai_feedback'
    )
    
    feedback_type = models.CharField(max_length=50, choices=FEEDBACK_TYPES)
    rating = models.IntegerField(choices=RATING_CHOICES)
    comment = models.TextField(blank=True, help_text="Optional detailed feedback")
    
    # Context information
    ai_metadata = models.ForeignKey(
        AIDocumentMetadata,
        on_delete=models.CASCADE,
        related_name='feedback',
        null=True,
        blank=True
    )
    
    # Specific feedback data
    feedback_data = models.JSONField(
        default=dict,
        blank=True,
        help_text="Specific feedback details (e.g., which tags were wrong)"
    )
    
    # Metadata
    model_version = models.CharField(max_length=50, blank=True)
    processing_time_ms = models.IntegerField(null=True, blank=True)
    
    created_at = models.DateTimeField(default=timezone.now)
    
    class Meta:
        db_table = "ai_user_feedback"
        indexes = [
            models.Index(fields=["user", "feedback_type"], name="idx_feedback_user_type"),
            models.Index(fields=["document", "feedback_type"], name="idx_feedback_doc_type"),
            models.Index(fields=["feedback_type", "rating"], name="idx_feedback_type_rating"),
            models.Index(fields=["created_at"], name="idx_feedback_created"),
        ]
    
    def __str__(self):
        return f"{self.user.username} - {self.feedback_type} - {self.rating}/5"
